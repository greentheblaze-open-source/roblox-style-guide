{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>A simplistic, community-driven extension of Roblox's Lua Style Guide.</p> <p>This guide covers best practices to follow when programming projects on the Roblox platform.</p> <p>Derived from Roblox's Lua Style Guide, this offers further rules, greater clarity, and a more intuitive format. If you value maintainability and readability within your code (and you don't want to waste time thinking about how it looks), this is your guide. Learning a style guide is a short-term endeavor, compared with the long-term struggles to understand ancient code.</p>"},{"location":"style-guide/","title":"Luau Style Guide","text":""},{"location":"style-guide/#type-checking","title":"Type Checking","text":"<p>Type checking is useful for identifying bugs in code. Here we recommend ways to utilize it where necessary (where inferred types are either unable to be identified, or are misleading).</p>"},{"location":"style-guide/#type-aliases","title":"Type Aliases","text":"<p>Type aliases are useful when creating either unique blueprints for objects, or indicating something could be more than one type. We use them only where necessary.</p> <ol> <li> <p>Do not ever assign type aliases to a single generic type.</p> <pre><code>type AnyCharacter = Character | PlayerCharacter\n</code></pre> <pre><code>type Success = boolean\n\nlocal success: Success = pcall(someFunction)\n</code></pre> <pre><code>-- It's cleaner to define them under a name rather than having to reference it through the module itself:\ntype Character = Types.Character\n</code></pre> </li> </ol>"},{"location":"style-guide/#defining-functional-types","title":"Defining Functional Types","text":"<p>When defining functions as types (not to be confused with Type Functions), you'll see syntax like the following...</p> <pre><code>type SomeFunction = (parameterA, parameterB) -&gt; ()\n</code></pre> <p>...where the the first set of brackets defines the parameters a function will have, and the last set defines a tuple for output values from that function.</p> <ol> <li> <p>If there is only 1 output value in a tuple, exclude the brackets - there's no need for them.</p> <pre><code>type CheckAlive = (character: Model) -&gt; boolean\n</code></pre> <pre><code>type CheckAlive = (character: Model) -&gt; (boolean)\n</code></pre> </li> </ol>"},{"location":"style-guide/#type-annotations","title":"Type Annotations","text":"<ol> <li>Always annotate declared variables.</li> <li>Never annotate variables that are initialized with a literal value.</li> <li>If a function in the same run context is said to return a specific type, do not type annotate the variable(s) that is to hold the result of the function when called.</li> <li>Use annotations when the result is not instantly obvious from a variable's initialization.</li> </ol>"},{"location":"style-guide/#type-casting","title":"Type Casting","text":""},{"location":"style-guide/#generics","title":"Generics","text":"<ol> <li> <p>All substitutions must be descriptive of what's being expected.</p> <pre><code>type Table&lt;Key, Value&gt; = { [Key]: Value }\ntype Dictionary&lt;Value&gt; = Table&lt;string, Value&gt;\n</code></pre> <pre><code>type Table&lt;K, V&gt; = { [K]: V }\ntype Dictionary&lt;V&gt; = Table&lt;string, V&gt;\n</code></pre> </li> </ol>"},{"location":"style-guide/#tables","title":"Tables","text":""},{"location":"style-guide/#lists","title":"Lists","text":"<ol> <li> <p>Put a space after an opening parenthesis and before a closing parenthesis.</p> <pre><code>local people = { \"Alex\", \"Fred\", \"Charlie\" }\n</code></pre> <pre><code>local people = {\"Alex\", \"Fred\", \"Charlie\"}\n</code></pre> </li> </ol>"},{"location":"style-guide/#dictionaries-objects","title":"Dictionaries &amp; Objects","text":"<ol> <li> <p>No index-like keys.</p> <pre><code>local hungerLevels = {\n    George = 10,\n    Mary = 12,\n    Fred = 20,\n}\nlocal oldestPerson = { name = \"George\" }\n</code></pre> <pre><code>local personA = {\n    [\"name\"] = \"Fred\",\n}\nlocal personB = { [\"name\"] = \"George\" }\n</code></pre> <pre><code>-- This should be a rare circumstance to ever need to do this though:\nlocal oddPersonA = {\n    [\"Mythically-Rare Name\"] = \"Fred\",\n}\n</code></pre> </li> <li> <p>Group related keys.</p> <pre><code>local tiers = {\n    fred = \"Low\",\n    george = \"Low\",\n\n    amy = \"Medium\",\n\n    charlie = \"High\",\n}\n</code></pre> </li> </ol>"},{"location":"style-guide/#comments","title":"Comments","text":""},{"location":"style-guide/#disabling-lines-of-code","title":"Disabling Lines of Code","text":"<ol> <li> <p>Use single-line comments.</p> <pre><code>-- local personA = {\n--    name = \"Fred\",\n-- }\n-- local personB = { name = \"George\" }\n</code></pre> <pre><code>--[[\n    local personA = {\n    name = \"Fred\",\n    }\n    local personB = { name = \"George\" }\n]]\n\n--[=[\n    local personA = {\n    name = \"Fred\",\n    }\n    local personB = { name = \"George\" }\n]=]\n</code></pre> </li> </ol>"}]}